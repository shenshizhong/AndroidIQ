1、app如何保活？
```
此处延伸：进程的优先级是什么

当前业界的Android进程保活手段主要分为** 黑、白、灰 **三种，其大致的实现思路如下：
黑色保活：不同的app进程，用广播相互唤醒（包括利用系统提供的广播进行唤醒）
白色保活：启动前台Service
灰色保活：利用系统的漏洞启动前台Service

黑色保活
所谓黑色保活，就是利用不同的app进程使用广播来进行相互唤醒。举个3个比较常见的场景：
场景1：开机，网络切换、拍照、拍视频时候，利用系统产生的广播唤醒app
场景2：接入第三方SDK也会唤醒相应的app进程，如微信sdk会唤醒微信，支付宝sdk会唤醒支付宝。
      由此发散开去，就会直接触发了下面的 场景3
场景3：假如你手机里装了支付宝、淘宝、天猫、UC等阿里系的app，那么你打开任意一个阿里系
      的app后，有可能就顺便把其他阿里系的app给唤醒了。（只是拿阿里打个比方，其实BAT系
      都差不多）
      
白色保活
白色保活手段非常简单，就是调用系统api启动一个前台的Service进程，
这样会在系统的通知栏生成一个Notification，用来让用户知道有这样一个app在运行着，
哪怕当前的app退到了后台。如下方的LBE和QQ音乐这样：

灰色保活
灰色保活，这种保活手段是应用范围最广泛。它是利用系统的漏洞来启动一个前台的Service进程，
与普通的启动方式区别在于，它不会在系统通知栏处出现一个Notification，看起来就如同运
行着一个后台Service进程一样。这样做带来的好处就是，用户无法察觉到你运行着一个前台进程
（因为看不到Notification）,但你的进程优先级又是高于普通后台进程的。那么如何利用系统的
漏洞呢，大致的实现思路和代码如下：

思路一：API < 18，启动前台Service时直接传入new Notification()；
思路二：API >= 18，同时启动两个id相同的前台Service，然后再将后启动的Service做stop处理
       熟悉Android系统的童鞋都知道，系统出于体验和性能上的考虑，app在退到后台时系统并
       不会真正的kill掉这个进程，而是将其缓存起来。打开的应用越多，后台缓存的进程也越多。
       在系统内存不足的情况下，系统开始依据自身的一套进程回收机制来判断要kill掉哪些进程，
       以腾出内存来供给需要的app。这套杀进程回收内存的机制就叫 Low Memory Killer ，
       它是基于Linux内核的 OOM Killer（Out-Of-Memory killer）机制诞生。进程的重要性，
       划分5级：

前台进程 (Foreground process)
可见进程 (Visible process)
服务进程 (Service process)
后台进程 (Background process)
空进程 (Empty process)
 
了解完 Low Memory Killer，再科普一下oom_adj。什么是oom_adj？它是linux内核分配给每个
系统进程的一个值，代表进程的优先级，进程回收机制就是根据这个优先级来决定是否进行回收。
对于oom_adj的作用，你只需要记住以下几点即可：

1、进程的oom_adj越大，表示此进程优先级越低，越容易被杀回收；越小，表示进程优先级越高，
越不容易被杀回收

2、普通app进程的oom_adj>=0,系统进程的oom_adj才可能<0

3、有些手机厂商把这些知名的app放入了自己的白名单中，保证了进程不死来提高用户体验（如微信、
QQ、陌陌都在小米的白名单中）。如果从白名单中移除，他们终究还是和普通app一样躲避不了
被杀的命运，为了尽量避免被杀，还是老老实实去做好优化工作吧。所以，进程保活的根本方案终究
还是回到了性能优化上，进程永生不死终究是个彻头彻尾的伪命题！
```