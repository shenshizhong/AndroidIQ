
volatile 怎么保证线程安全的？
```
它能够保证每个线程拿到的变量都是最新值。

怎么保证拿到的都是最新的呢？

```
什么是内存可见性
```
java 虚拟机试图定义一种java 内存模型（JMM），来屏蔽各种硬件和系统内存的访问差异。
cpu执行指令的速度很快，但是内存访问的速度就慢很多。所以就出现了
高速缓存。
所有变量都存在主存中（寄存器或者高速缓存），线程有自己的工作内存，
等工作前后都要把值同步到主存中。

什么是java内存模型呢？
java内存模型是一种规范，定义了很多东西，所有的变量存储在主内存中，
每个线程都有自己的本地内存，本地内存存储了该线程的读写共享变量的拷贝副本，
线程对变量的读写都是在本地内存中的，而不能直接再主内存中。

工作线程是怎么操作内存的呢？
先从主存中获取变量值，再把值load 到工作内存的副本中，然后再传递给处理器，
执行完呢，再给工作内存中的副本赋值，然后工作内存再把值传会给主存，
主存中的值才更新。

什么是原子性？
i = 1；  //只是读取的操作，所以满足原子性
j = i；  //读取i的值1，还要进行赋值操作，所以不是原子性操作。
i = i + 1； //读取i的值1，还要进行加1，然后再写回主存中，所以不是原子性操作。

怎么才能把i++的操作，变成原子性操作呢？
必须借助synchronized 和 lock 来保证整块的原子操作，
也就是线程在释放锁之前，必须把i的值刷回到主存中。

什么是可见性呢？
就是说一个线程修改了共享的变量之后，其他线程能够得知这个变量修改了。

那么怎么保证可见性性呢？
1、java 利用关键字volatile来提供可见性。当变量被volatile修饰，
对它的修改就会立即刷回到主存中，这样其他线程就能获取到最新值。
2、通过synchronized 和 Lock 也可以保证可见性，在线程释放锁之前，把变量刷回主存中。
但是呢，synchronized 和 Lock 的开销会更大，不建议。

什么是有序性呢？
JMM 允许编译器和处理器对指令重排序，就说不管怎么重排序，程序执行结果不能改变。

int a = 1; //A
int b = 2; //B
int c = a + b + 1; //C

这样的语句可以按照 A->B->C执行，也可以B->A->C, 因为A和B是独立的语句，而C却是需要依赖AB的，
所以A B 是可以重排序的，但是C 却不可以放到 A B 的前面，放前面，就不知道拿不到a，b 的值了。
JMM 保证了重排序不影响单线程的执行，但是多线程就不能保证了。
比如：
int a = 0;
boolean flag = false;
public void init(){
   a = 1;       //1
   flag = true;   //2
}
public void add(){
     if(flag){       //3
        int result = a + a;  //4
     }
}

如果有两个线程同时执行，线程1先执行 init(), 然后线程2 执行add(), 这个时候result 的结果一定是2么？
结果不一定。
为什么呢？
有可能得执行过程是这样的，就是 init() 先执行了 flag = true，线程了立马接上去执行了 add(),
这个时候其实 a = 1，是没执行的，也就是 a 还是0，等到执行完 add（），线程1，这个时候才执行赋值操作 a = 1；
那么显然就出现问题了，结果就result 的值是0。因为跳过 a = 1，的操作。
执行的过程变成了 2 —> 3 -> 4 -> 1; 结果肯定不对。

怎么解决重排序的问题呢？
即使给flag加上volatile 这个关键字，加上之后呢，就能够禁止重排序。

volatile 是怎么满足并发的三大特性（可见性，原子性，有序性）?
比如：
int a = 0;
boolean flag = false;
public void init(){
   a = 1;       //1
   flag = true;   //2
}
public void add(){
     if(flag){       //3
        int result = a + a;  //4
     }
}

在多线程中，假如1、2没有重新排序，3 也不一定能能顺利执行的，假设还是线程1先执行init();
线程2再执行add()操作，由于线程1在工作内存中把flag 赋值为true，不一定立刻写回主存中，
这个时候线程了执行add（）时候，发现flag 还是false，这个时候里头的代码就不会执行。

所以解决的方案是什么呢？

int a = 0;
volatile boolean flag = false;  //加上volatile
public void init(){
   a = 1;       //1
   flag = true;   //2
}
public void add(){
     if(flag){       //3
        int result = a + a;  //4
     }
}

加上关键字volatile ，这个时候，线程1执行init(),线程2再执行add(),
volatile 限制了指令的重排序，所以 1会在2之前执行。
整过过程的原理是什么呢？
在写一个volatile 变量的时候，JMM 会把该线程的本地内存共享变量同步到主存中。
在读一个volatile 变量的时候呢，JMM 会把该内存的本地内存设置为无效，线程跑去主存中获取最新值。

volatile 能够保证可见性，有序性，能够保证原子性呢？
volatile 只能保证当个变量的读写具备原子性，对于volatile++的复合操作是不具备原子性的。
比如 volatile int i  = 0; i++;

当多个线程对 i++ 进行操作，就不能保证i 的原子性操作。
这是一个复合的操作：获取i -> i自增加 -> 回写i

线程1 和线程2 同时自增i。由于volatile 可见性，所以两个线程拿到的都是最新的i。
接下来是自增就有问题了，
有可能出现的场景是 线程1 自增i并回写了，但是线程2 在线程1回写前 已经拿到i了，
这个时候线程2 就没拿到线程1的回写，然后进行了一次自增并回写。相当于作了重复的工作。
这样操作的结果就会不对。

有的人可能会说，线程1对i进行自增的操作，不是会通知其他缓存，并进行重新load么？
拿的前提是读，问题是线程1对i进行了自增，线程2 已经拿到i了，并不存在再次读取的情况，也就不会触发load。
说白了，就是线程1 对i自增操作是一个复合的操作，不是原子操作，导致的。
这里如果说改成赋值i=2,这种就是原子操作，就不会有问题。


volatile 底层的实现机制是什么呢？
当我们把加了volatile 和 没有加入volatile 的代码生成汇编代码的时候，
会发现volatile 会多加一个lock 前缀指令。

那么这个lock前缀指令的功能是干什么的呢？
1、会强制写入主存
2、避免前后指令的CPU重排序
3、让其他核中的缓存失效（也就是其他线程的缓存失效）

CPU 和线程的关系是什么呢？
线程是CPU调度的最小单位
CPU 是多核的，一般一个核对应一个线程。但Intel引入了超线程技术之后，核心数与线程数变成1：2关系。

一般在哪些地方会用到volatile 呢？
在写当单例的时候最容易碰到volatile的。
目的就是为了多线程同时访问一个实例，避免出现线程安全问题。
比如：

class SingleInstance {
  private static volatile SingleInstance singleInstance;//这里使用volatile 关键字
  private SingleInstance(){}
  public static SingleInstance getInstance(){
    if (singleInstance == null){
      synchronized (SingleInstance.class){
        if (singleInstance == null){
           singleInstance = new SingleInstance();
        }
      }
    }
    return  singleInstance;
  }
}

```
[详细地址：https://juejin.cn/post/6844903520760496141](https://juejin.cn/post/6844903520760496141)