#内存泄漏

Handler 的内存泄漏
```
静态类不持有外部类的对象，所以Activity可以随意被回收
private static class MyHandler extends Handler {
    @Override
    public void handleMessage(Message msg) {
        super.handleMessage(msg);
    }
}

如果需要使用Activity中的对象，那么对Activity进行弱引用
private final MyHandler mHandler = new MyHandler(this);
private static class MyHandler extends Handler {
    private final WeakReference<Activity> mActivity;
    public MyHandler(Activity activity) {
      mActivity = new WeakReference<Activity>(activity);
    }

    @Override
    public void handleMessage(Message msg) {
      final Activity activity = mActivity.get();
      if (activity != null) {
        // doSomething
      }
    }
  }
  
对于匿名类Runnable
private static final Runnable mRunnable = new Runnable() {
      @Override
      public void run() { 
          // doSomething
      }
  };

 需要引用外部类内容情况：
 private static class MyRunnable implements Runnable {
        private WeakReference<Activity> reference;

        MyRunnable(Activity activity) {
            reference = new WeakReference<>(activity);
        }

        @Override
        public void run() {
            if (reference == null || reference.get() == null) return;
            Activity activity = reference.get();
            activity.getActionBar();//就可以去拿当前的类的成员变量及方法了。
            activity.todo();
        }
    }

    //外部定义一个方法，就省得activity. 每个成员变量
    public void todo() {

    }

```
[详细地址：https://www.jianshu.com/p/daffbb9ddc17](https://www.jianshu.com/p/daffbb9ddc17)

Dialog 
```
PhoneWindow.mDecor 导致的内存泄漏。
原因：是dismiss之后要释放资源，把Dialog 的 DecorView 和 PhoneWindow 都释放掉。
如果用同一个dialog 进行show，此时DecorView 和 PhoneWindow 就不能释放掉。

解决方案：

每次都创建一个新的dialog。
CommonDialog mDialog = new CommonDialog(this);

@Override
    protected void onDestroy() {
        super.onDestroy();
        if (mDialog != null){
            mDialog.cancel();
            mDialog = null;
        }
    }
```
[详细地址：https://blog.csdn.net/m0_37707561/article/details/114262438](https://blog.csdn.net/m0_37707561/article/details/114262438)
