1、处理定位
```
1、直接跳到定位效果
 private void moveToPosition(int position) {
        if (position != -1) {
            mRecyclerView.scrollToPosition(position);
            LinearLayoutManager mLayoutManager =
                    (LinearLayoutManager) mRecyclerView.getLayoutManager();
            mLayoutManager.scrollToPositionWithOffset(position, 0);
        }
    }

2、平滑到定位位置
    private void smoothMoveToPosition(int position){
        if (position != -1) {
            smoothMoveToPosition(mRecyclerView,position);
        }else {
            smoothMoveToPosition(mRecyclerView,position+1);
        }
    }

    private void iniSmoothMove() {
        mRecyclerView.addOnScrollListener(new RecyclerView.OnScrollListener()
        {
            @Override
            public void onScrollStateChanged (RecyclerView recyclerView,int newState){
                super.onScrollStateChanged(recyclerView, newState);
                if (mShouldScroll && RecyclerView.SCROLL_STATE_IDLE == newState) {
                    mShouldScroll = false;
                    smoothMoveToPosition(recyclerView, mToPosition);
                }
            }
        });
    }

    //目标项是否在最后一个可见项之后
    private boolean mShouldScroll;
    //记录目标项位置
    private int mToPosition;
    /**
     * 滑动到指定位置
     */
    private void smoothMoveToPosition(RecyclerView mRecyclerView, final int position) {
        // 第一个可见位置
        int firstItem = mRecyclerView.getChildLayoutPosition(mRecyclerView.getChildAt(0));
        // 最后一个可见位置
        int lastItem = mRecyclerView.getChildLayoutPosition(mRecyclerView.getChildAt(mRecyclerView.getChildCount() - 1));
        if (position < firstItem) {
            // 第一种可能:跳转位置在第一个可见位置之前
            mRecyclerView.smoothScrollToPosition(position);
        } else if (position <= lastItem) {
            // 第二种可能:跳转位置在第一个可见位置之后
            int movePosition = position - firstItem;
            if (movePosition >= 0 && movePosition < mRecyclerView.getChildCount()) {
                int top = mRecyclerView.getChildAt(movePosition).getTop();
                mRecyclerView.smoothScrollBy(0, top);
            }
        } else {
            // 第三种可能:跳转位置在最后可见项之后
            mRecyclerView.smoothScrollToPosition(position);
            mToPosition = position;
            mShouldScroll = true;
        }
    }
```
[详细地址： https://blog.csdn.net/shanshan_1117/article/details/78780137](https://blog.csdn.net/shanshan_1117/article/details/78780137)

2、更新局部控件
```
  
  @Override
    public void onBindViewHolder(@NonNull RecyclerView.ViewHolder holder, int position, @NonNull List payloads) {
        HouseResViewHolder viewHolder = (HouseResViewHolder) holder;

        RecReadDataModel recommendedReadListModel = mList.get(position);
        if (recommendedReadListModel == null) return;

        if (payloads.isEmpty()) {     //正常绑定数据逻辑

            bindViewData(position, viewHolder, recommendedReadListModel);

        } else {  //刷新一个指定item中的点赞view 而不是重新渲染这个item中的所有view 解决了点赞时item闪动问题

            //设置点赞状态
            setPraiseState(position, viewHolder, recommendedReadListModel);

        }
        

 使用方式：    
 notifyItemChanged(position,"payload");
```
[https://www.jianshu.com/p/debbad6de0d0](https://www.jianshu.com/p/debbad6de0d0)
更细微的局部刷新
```
notifyItemChanged(position,0);
notifyItemChanged(position,1);

 {
 int type= (int) payloads.get(0);// 刷新哪个部分 标志位
            switch(type){
            case 0:
                 ...
            break;
            case 1:
                 ...
            break;
            }
            
 }
```
[详细地址 https://blog.csdn.net/qq402164452/article/details/53464091](https://blog.csdn.net/qq402164452/article/details/53464091)


3、RecyclerView 使用的优化
```
setHasFixedSize(true); 的作用固定RecyclerView 的大小，减少重绘
需要改变rv的宽高时，用notifyDataSetChanged()去整体刷新一下

```
[详细地址：https://www.jianshu.com/p/f32929e65313](https://www.jianshu.com/p/f32929e65313)

获取RecyclerView 中的控件
```
主要是通过LayoutManager 去获取：
View view = mLayoutManager.findViewByPosition(2);	//2为recyclerView中item位置，

```
[详细地址：https://blog.csdn.net/d06110902002/article/details/68495853](https://blog.csdn.net/d06110902002/article/details/68495853)

android:clipToPadding 的使用
```
clipToPadding： 是否裁剪子view，默认值是true （如果padding 不为0，调整边缘效果）


    <android.support.v7.widget.RecyclerView
        android:id="@+id/recycler_view"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:clipToPadding="false"
        android:paddingLeft="10dp"
        android:paddingRight="10dp"
        android:paddingTop="10dp"/>

    <View
        android:layout_width="match_parent"
        android:layout_height="5dp"
        android:layout_marginLeft="-10dp"
        android:layout_marginRight="-10dp"
        android:background="@android:color/holo_orange_light"/>




第二个示例：
activity_list.xml
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent" >

    <androidx.appcompat.widget.Toolbar
        xmlns:app="http://schemas.android.com/apk/res/com.example.toolbar"
        android:id="@+id/toolbar"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:background="#29b6f6"
        android:minHeight="50dip" >

        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="我的标题栏" />
    </androidx.appcompat.widget.Toolbar>

    <ListView
        android:id="@+id/listView"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:clipToPadding="false"
        android:paddingTop="60dip"
         />
<!--  android:clipToPadding="false"  原始listView与顶部有距离，滑动与顶部没距离-->
<!--  说白了，就是滑动就不做裁剪，相当于没有padding -->
</RelativeLayout>

 class ListActivity : AppCompatActivity(){
    private val a = 0;
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_list)

        val mToolbar = findViewById<Toolbar>(R.id.toolbar)
        mToolbar.setLogo(R.mipmap.ic_launcher)
        mToolbar.title = "zhangphil"

        val lv = findViewById<ListView>(R.id.listView)

        val data = arrayOfNulls<String>(50)
        for (i in data.indices) {
            data[i] = "数据$i"
        }

        val adapter = ArrayAdapter(this, android.R.layout.simple_list_item_1, data)
        lv.adapter = adapter

    }

}

```
[详细地址：https://blog.csdn.net/wangjiang_qianmo/article/details/54604378](https://blog.csdn.net/wangjiang_qianmo/article/details/54604378)
[详细地址：https://blog.csdn.net/zhangphil/article/details/48680055](https://blog.csdn.net/zhangphil/article/details/48680055)