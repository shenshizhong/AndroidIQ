
1、使用EventBus 的坑
```
接收不到post

原因：
使用同名的其他库中的类了
1、使用了其他库中的 EventBus 
2、使用了其他库中的 @Subscribe

```
2、图片的问题
```
Java.Lang.IllegalStateException: Failed to build unique file: /storage/emulated/0/Pictures

```
[详细地址： https://stackoverflow.com/questions/58487750/app-crashes-on-storing-the-bitmap-on-andorid-10-even-if-target-sdk-is-set-to-28](https://stackoverflow.com/questions/58487750/app-crashes-on-storing-the-bitmap-on-andorid-10-even-if-target-sdk-is-set-to-28)

3、tablayout 设置图片
 ```
 UncaughtException detected: java.lang.NullPointerException: Attempt to invoke virtual method 'android.support.design.widget.TabLayout$Tab android.support.design.widget.TabLayout$Tab.setIcon(android.graphics.drawable.Drawable)' on a null object reference
        at com.zizaihome.fozhu.main.blessing.adapter.BlessingViewBinder.onBindViewHolder(BlessingViewBinder.java:66)
        at com.zizaihome.fozhu.main.



tabLayout.setupWithViewPager(viewPager);
TabLayout.Tab tab = tabLayout.getTabAt(0);
tab.setIcon(new IconicsDrawable(this).icon(FontAwesome.Icon.faw_home));
viewPager.setAdapter(new CustomAdapter(getSupportFragmentManager(), getApplicationContext()));

问题原因：setIcon放的位置不对
正确的设置顺序如下：

viewPager.setAdapter(new CustomAdapter(getSupportFragmentManager(), getApplicationContext()));
tabLayout.setupWithViewPager(viewPager);
TabLayout.Tab tab = tabLayout.getTabAt(0);
tab.setIcon(new IconicsDrawable(this).icon(FontAwesome.Icon.faw_home));

```
3、场景是recyclerview 中潜入tablayout+viewpager,每次切换fragment都会viewpager滚动到顶部. 
```
解决方法:recyclerview  的父布局加上 
android:focusable="true" 
android:focusableInTouchMode="true"
```
4、打包相关问题，gradle 的方法过时问题
```
INFO: API 'variant.getAssemble()' is obsolete and has been replaced with
 'variant.getAssembleProvider()'
 
```
[详细地址 https://blog.csdn.net/angcyo/article/details/78357512](https://blog.csdn.net/angcyo/article/details/78357512)

5、Cannot find declaration to go to

```
只要跟目录下的.iml 删除，关闭AS，重新打开就可以了。
AS 会自动生成新的正确的 .iml
```
6、按钮多次点击才生效问题
```
mNow.setOnClickListener(new View.OnClickListener() {
     mNow.setOnClickListener(){}
}

设置多次的setOnClickListener导致的，只要保持一个setOnClickListener就没问题了

```
7、混淆文件的错误提示：ProguardTokenType.CRLF, ProguardTokenType.FLAG_ARG,
 ProguardTokenType.LINE_CMT or ProguardTokenType.OPEN_BRACE expected, unexpected end of file
```
这是格式的问题，把花括号调整位置就可以了
-keepclassmembers class * extends android.app.Activity
{
   public void *(android.view.View);
}

-keepclassmembers class * extends android.app.Activity{
   public void *(android.view.View);
}
```
8、混淆文件的错误提示：ProguardTokenType.CRLF, ProguardTokenType.FLAG_NAME, 
ProguardTokenType.LINE_CMT or ProguardTokenType.WS expected, got ''
```
这是出现了重复的代码或者格式错误
比如以下2种情况的解决方案：
 -keep class android.support.**{*;}  //重复了，只留一个

-dontnote com.xiaomi.**      //前面可能出现了特殊的空格，可以换行重新写一遍就好了

```
3、Selector 在drawable和color目录下使用的规范
```

```
手机debug闪退的问题
```
Disconnected from the target VM, address: 'localhost:8602', transport: 'socket'
解决方案：
Run->Edit Configuration->Debugger->Build Type设置为 Dual（Java + Native）模式，则可以正常调试。

```
[详细地址： https://blog.csdn.net/pifutan/article/details/77967123](https://blog.csdn.net/pifutan/article/details/77967123)

IndexOutOfBoundsException 越界
```
Color.parseColor(color);
color 不能是空，如果为""，就会有这个问题。如下源码一看就明白

public static int parseColor(@Size(min=1) String colorString) {
        if (colorString.charAt(0) == '#') {
            ...
            return (int)color;
        } else {
            ...
        }
    }
```
点击事件被占用
```
问题：在复用中的按钮，如果没有置空，导致点击其他按钮也触发了同一事件。


        worshipTv.setOnClickListener(null);    //解决问题的关键
        if (item.getType() == 1){
            if ( 0 == item.getStock()){
                soldOutTv.setVisibility(View.VISIBLE);
                worshipTv.setSelected(false);
                worshipTv.setOnClickListener(null);
            }else{
                soldOutTv.setVisibility(View.GONE);
                worshipTv.setSelected(true);
                worshipTv.setOnClickListener((v)->{
                    FoshiHelper.click((BaseActivity) mContext,worshipTv, item);
                });
            }

        }else if(item.getType() == 2){
            soldOutTv.setVisibility(View.GONE);
            worshipTv.setSelected(true);
            worshipTv.setOnClickListener((v)->{
                JumpUtil.jumpCommonBrowser(mContext, item.getLink());
            });
        }

需要把监听事件置空，不然事件一直被占用，
点了其他按钮也会执行相同的事件（相当于使用了同一监听事件）
```

解决白屏问题
```
<style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar">
    ......
    <item name="android:windowIsTranslucent">true</item>
    <item name="android:windowNoTitle">true</item>
</style>

或者：加个背景图
<style name="SplashAppTheme" parent="Theme.AppCompat.Light.NoActionBar">
        <item name="android:windowBackground">@drawable/splash_logo_welcome</item>
        <item name="android:windowFullscreen">true</item>
</style>
```
[详细地址：https://www.jianshu.com/p/be94c899b945](https://www.jianshu.com/p/be94c899b945)

8.0 不能在后台开启服务
```
Caused by java.lang.IllegalStateException: Not allowed to start service Intent { act=start cmp=PKGN/com.github.dawndiy.proxy.ProxyService }: app is in background uid UidRecord{3551e9b u0a465 SVC  idle procs:2 seq(0,0,0)}
       at android.app.ContextImpl.startServiceCommon(ContextImpl.java:1505)

原因：
8.0 对后台进程做了限制，不准在后台的情况下，通过startService启动服务

解决方案一：
使用 startForegroundService，但会跳出提示给使用者知道

方案二：（也是推荐的方案）

public class MyServiceNew extends JobIntentService {
    private MediaPlayer player;
    
    @Override
    public void onCreate() {
        super.onCreate();
    }
    static final int SERVICE_JOB_ID = 50;
    public static void enqueueWork(Context context, Intent work) {
        enqueueWork(context, MyServiceNew.class, SERVICE_JOB_ID, work);
    }

    @Override
    protected void onHandleWork(@NonNull Intent intent) { //处理在后台需要执行的内容
        player = MediaPlayer.create(this,
                Settings.System.DEFAULT_RINGTONE_URI);
        player.setLooping(true);
        player.start();
    }
}

清单中声明：
<uses-permission android:name="android.permission.FOREGROUND_SERVICE" />
<uses-permission android:name="android.permission.WAKE_LOCK" />

<service android:name=".MyServiceNew"
            android:exported="false"
            android:permission="android.permission.BIND_JOB_SERVICE">
            
            
使用：
 new Handler().postDelayed(new Runnable() {
            @Override
            public void run() {
                Intent intent = new Intent(MainActivity.this, MyServiceNew.class);
                MyServiceNew.enqueueWork(MainActivity.this, intent);
                Log.e("ssz","========延迟执行");
            }
        },1000 * 65);


```
[详细地址：https://blog.csdn.net/wxz1179503422/article/details/83031724](https://blog.csdn.net/wxz1179503422/article/details/83031724)
[详细地址：https://stackoverflow.com/questions/51532059/android-gcm-wakefulbroadcastreceiver-startwakefulservice-crash-due-to-illegals](https://stackoverflow.com/questions/51532059/android-gcm-wakefulbroadcastreceiver-startwakefulservice-crash-due-to-illegals)

安装APP 失败 INSTALL_FAILED_TEST_ONLY
```
在vivo 手机上出现过。
解决方案：
gradle.properties 文件中，添加 android.injected.testOnly=false
```
[详细地址：https://blog.csdn.net/aikongmeng/article/details/102589809](https://blog.csdn.net/aikongmeng/article/details/102589809)
