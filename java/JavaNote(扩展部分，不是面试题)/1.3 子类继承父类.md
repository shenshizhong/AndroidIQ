#方法执行顺序

子类继承父类方法执行顺序
```
父类的静态代码块-》子类的静态代码块-》主方法（当下执行的哪个程序就执行哪个程序的主方法）
-》父类的非静态代码块-》父类的无参构造函数-》子类的非静态代码块-》子类的无参构造函数
-》成员函数（若重写了父类的成员函数，则只执行子类的成员函数）

一句话：先父再子
```
[详细地址：https://blog.csdn.net/superit401/article/details/52068004](https://blog.csdn.net/superit401/article/details/52068004)

一个类的执行顺序
```
成员变量 -> 构造方法 

/**
 * 先父类静态 -> 子类静态 —> （父类普通 + 构造） -> （子类普通 + 构造）
 * 静态参数 -> 静态代码块 -> 参数 -> 代码块 -> 构造方法

 * 1、父类静态变量和静态代码块（先声明的先执行）；
 * 2、子类静态变量和静态代码块（先声明的先执行）；
 * 3、父类的变量和代码块（先声明的先执行）；
 * 4、父类的构造函数；
 * 5、子类的变量和代码块（先声明的先执行）；
 * 6、子类的构造函数。
 * Created by ssz on 2021/11/26
 */
public class Run {
    public static void main(String[] args){
        new Child();
    }
}


/**
 * Created by ssz on 2021/11/26
 */
public class Child extends Parent{
    static FooNew fooNew = new FooNew("Child's static parameter");

    FooNew fooNew2 = new FooNew("Child's parameter");

    static {
        System.out.println("Child's static code block");
    }

    {
        System.out.println("Child's code block");
    }

    /**
     * 这是构造方法
     * */
    public Child(){
        System.out.println("Child.child()");
    }
}

/**
 * Created by ssz on 2021/11/26
 */
public class Parent {
    public Parent(){
        System.out.println("Parent.Parent()");
    }
    //父类的静态参数
    static FooNew fooNew = new FooNew("Parent's static parameter");

    FooNew fooNew2 = new FooNew("Parent's parameter");

    static {
        System.out.println("Parent's static code block");
    }

    {
        System.out.println("Parent's code block");
    }
    
}

public class FooNew {
     public FooNew(String word){
         System.out.println(word);
     }
}

```
[详细地址：https://www.cnblogs.com/jj-chenjunjie/p/5331107.html](https://www.cnblogs.com/jj-chenjunjie/p/5331107.html)